<#@ template language="C#" debug="True" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension="cs" #>
<#@ include file="T4Toolbox.tt" #>
// ------------------------------------------------------------------------------
//  <auto-generated>
//    Generated by NCop Copyright © <#= DateTime.Today.Year #>
//    Changes to this file may cause incorrect behavior and will be lost if
//    the code is regenerated.
// </auto-generated
// ------------------------------------------------------------------------------
using System;
using NCop.Aspects.Engine;
using NCop.Aspects.Framework;
using System.Collections.Generic;

namespace NCop.Aspects.Extensions
{
	internal static class AspectArgsContractResolver
	{
		private static readonly IDictionary<int, Type> funcArgsMap = null;
		private static readonly IDictionary<int, Type> actionArgsMap = null;

		static AspectArgsContractResolver() {
			funcArgsMap = new Dictionary<int, Type>();
			actionArgsMap = new Dictionary<int, Type>();

<#
foreach (var i in Enumerable.Range(1, 8)) {
	string commas = string.Concat(Enumerable.Repeat(",", i - 1));
#>
			funcArgsMap.Add(<#= i #>, typeof(IFunctionArgs<<#= commas #>>));	
			actionArgsMap.Add(<#= i #>, typeof(IActionArgs<<#=commas#>>));	
<#
	if (i != 8) {
		WriteLine(""); 
	}
}#>
		}

		internal static Type ToFunctionAspectArgument(this Type[] typeArguments) {
			return funcArgsMap[typeArguments.Length].MakeGenericType(typeArguments);
		}
		
		internal static Type ToActionAspectArgument(this Type[] typeArguments) {
			return actionArgsMap[typeArguments.Length].MakeGenericType(typeArguments);
		}
		
		internal static Type ToAspectArgument(this Type[] typeArguments, bool isFunction) {
			if (isFunction) {
				return typeArguments.ToFunctionAspectArgument();
			}

			return typeArguments.ToActionAspectArgument();
		}	
	}
}